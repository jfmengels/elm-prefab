
import * as path from "path";
import * as fs from "fs";

export const copyTo = (baseDir: string, overwrite: boolean) => { 
  
  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Markdown.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Markdown.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Markdown.elm"), "module App.Markdown exposing (Model, Msg, Page, page)\n\n{-| -}\n\nimport App\nimport Browser\nimport Html exposing (Html)\nimport Http\nimport Markdown.Block\nimport Markdown.Parser\nimport Markdown.Renderer\nimport Result\n\n\ntype alias Model =\n    { source : { sourceUrl : String }\n    , markdown : Result (List String) (List Markdown.Block.Block)\n    }\n\n\ntype Msg\n    = MarkdownReceived (Result Http.Error String)\n\n\ntype alias Page shared =\n    App.Page { sourceUrl : String } shared Model Msg (Browser.Document Msg)\n\n\npage : String -> Page shared\npage markdown =\n    App.page\n        { init =\n            \\params shared ->\n                ( { source = params\n                  , markdown =\n                        Markdown.Parser.parse markdown\n                            |> Result.mapError (List.map Markdown.Parser.deadEndToString)\n                  }\n                , App.get\n                    { url = params.sourceUrl\n                    , expect =\n                        Http.expectString MarkdownReceived\n                    }\n                )\n        , update = update\n        , subscriptions = \\pageUnpack unpack -> App.Subscription Sub.none\n        , view =\n            \\model ->\n                { title = \"test\"\n                , body =\n                    case model.markdown of\n                        Ok parsed ->\n                            case\n                                Markdown.Renderer.render\n                                    Markdown.Renderer.defaultHtmlRenderer\n                                    parsed\n                            of\n                                Ok rendered ->\n                                    rendered\n\n                                Err errorText ->\n                                    [ Html.text errorText ]\n\n                        Err parsingErrors ->\n                            [ Html.text \"Error parsing\" ]\n                }\n        }\n\n\nupdate msg model =\n    case msg of\n        MarkdownReceived (Err err) ->\n            ( model, App.none )\n\n        MarkdownReceived (Ok markdown) ->\n            ( { model\n                | markdown =\n                    Markdown.Parser.parse markdown\n                        |> Result.mapError (List.map Markdown.Parser.deadEndToString)\n              }\n            , App.none\n            )\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Page.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Page.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Page.elm"), "module App.Page exposing\n    ( Page, page\n    , Init, init, initWith, notFound, loadFrom\n    , withKey\n    , InitPlan(..), toInternalDetails, mapInitPlan\n    )\n\n{-|\n\n@docs Page, page\n\n@docs Init, init, initWith, notFound, loadFrom\n\n@docs withKey\n\n\n# Internal Details\n\nThese are\n\n@docs InitPlan, toInternalDetails, mapInitPlan\n\n-}\n\nimport App.Effect\nimport App.Shared\nimport App.Sub\nimport App.View\n\n\n{-| -}\ntype Page params msg model\n    = Page\n        { init : params -> App.Shared.Shared -> Maybe model -> Init msg model\n        , update : App.Shared.Shared -> msg -> model -> ( model, App.Effect.Effect msg )\n        , subscriptions : App.Shared.Shared -> model -> App.Sub.Sub msg\n        , view : App.Shared.Shared -> model -> App.View.View msg\n        , toKey : params -> Maybe String\n        }\n\n\n{-| -}\npage :\n    { init : params -> App.Shared.Shared -> Maybe model -> Init msg model\n    , update : App.Shared.Shared -> msg -> model -> ( model, App.Effect.Effect msg )\n    , subscriptions : App.Shared.Shared -> model -> App.Sub.Sub msg\n    , view : App.Shared.Shared -> model -> App.View.View msg\n    }\n    -> Page params msg model\npage options =\n    Page\n        { init = options.init\n        , update = options.update\n        , subscriptions = options.subscriptions\n        , view = options.view\n        , toKey = \\_ -> Nothing\n        }\n\n\n{-| -}\nwithKey : (params -> String) -> Page params msg model -> Page params msg model\nwithKey toKey (Page details) =\n    Page\n        { init = details.init\n        , update = details.update\n        , subscriptions = details.subscriptions\n        , view = details.view\n        , toKey = \\params -> Just (toKey params)\n        }\n\n\n{-| -}\ntype alias Init msg model =\n    InitPlan msg model\n\n\n{-| -}\ntype InitPlan msg model\n    = NotFound\n    | Loaded model (App.Effect.Effect msg)\n    | LoadFrom (App.Effect.Effect (InitPlan msg model))\n\n\n{-| -}\nmapInitPlan :\n    { onModel : model -> model2\n    , onMsg : msg -> msg2\n    }\n    -> InitPlan msg model\n    -> InitPlan msg2 model2\nmapInitPlan ({ onModel, onMsg } as fns) initPlan =\n    case initPlan of\n        NotFound ->\n            NotFound\n\n        Loaded model effect ->\n            Loaded (onModel model) (App.Effect.map onMsg effect)\n\n        LoadFrom effect ->\n            LoadFrom (App.Effect.map (mapInitPlan fns) effect)\n\n\n{-| -}\ninit : model -> Init msg model\ninit model =\n    Loaded model App.Effect.none\n\n\n{-| -}\ninitWith : model -> App.Effect.Effect msg -> Init msg model\ninitWith model effect =\n    Loaded model effect\n\n\n{-| -}\nnotFound : Init msg model\nnotFound =\n    NotFound\n\n\n{-| -}\nloadFrom : App.Effect.Effect (Init msg model) -> Init msg model\nloadFrom effect =\n    LoadFrom effect\n\n\n\n{- Internal -}\n\n\n{-| -}\ntoInternalDetails :\n    Page params msg model\n    ->\n        { init : params -> App.Shared.Shared -> Maybe model -> Init msg model\n        , update : App.Shared.Shared -> msg -> model -> ( model, App.Effect.Effect msg )\n        , subscriptions : App.Shared.Shared -> model -> App.Sub.Sub msg\n        , view : App.Shared.Shared -> model -> App.View.View msg\n        }\ntoInternalDetails (Page details) =\n    details\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/State.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/State.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/State.elm"), "module App.State exposing\n    ( Cache, init, current, get\n    , Loaded(..)\n    , setCurrent, insert, toNotFound, toLoading\n    , clearCurrent\n    )\n\n{-|\n\n@docs Cache, init, current, get\n\n@docs Loaded\n\n@docs setCurrent, insert, toNotFound, toLoading\n\n-}\n\nimport Dict\n\n\ntype Cache state\n    = Cache\n        { current :\n            Maybe\n                { key : String\n                , state : Loaded state\n                }\n        , cache : Dict.Dict String (Loaded state)\n        }\n\n\ntype Loaded state\n    = Loading\n    | NotFound\n    | Loaded state\n\n\n{-| -}\ninit : Cache state\ninit =\n    Cache\n        { current = Nothing\n        , cache = Dict.empty\n        }\n\n\n{-| -}\ncurrent : Cache state -> Loaded state\ncurrent (Cache details) =\n    case details.current of\n        Nothing ->\n            NotFound\n\n        Just currentState ->\n            currentState.state\n\n\n{-| -}\ntoNotFound : String -> Cache state -> Cache state\ntoNotFound key cache =\n    insertLoaded key NotFound cache\n\n\n{-| -}\ntoLoading : String -> Cache state -> Cache state\ntoLoading key cache =\n    insertLoaded key Loading cache\n\n\n{-| This is called when there is no clear new current state.\n\nSuch as when the URL has changed to a new page that does not exist.\n\n-}\nclearCurrent : Cache state -> Cache state\nclearCurrent (Cache details) =\n    Cache\n        { details\n            | current = Nothing\n            , cache =\n                -- move the current state to the cache if it needs to be\n                case details.current of\n                    Nothing ->\n                        details.cache\n\n                    Just previousCurrent ->\n                        details.cache\n                            |> Dict.insert previousCurrent.key previousCurrent.state\n        }\n\n\n{-| -}\nsetCurrent : String -> Cache state -> Cache state\nsetCurrent key cache =\n    let\n        (Cache cleared) =\n            clearCurrent cache\n    in\n    Cache\n        { cleared\n            | current =\n                Just\n                    { key = key\n                    , state =\n                        Dict.get key cleared.cache\n                            |> Maybe.withDefault NotFound\n                    }\n            , cache =\n                Dict.remove key cleared.cache\n        }\n\n\n{-| -}\nget : String -> Cache state -> Maybe state\nget key (Cache details) =\n    case details.current of\n        Nothing ->\n            case Dict.get key details.cache of\n                Just (Loaded state) ->\n                    Just state\n\n                _ ->\n                    Nothing\n\n        Just cur ->\n            if cur.key == key then\n                case cur.state of\n                    Loaded state ->\n                        Just state\n\n                    _ ->\n                        Nothing\n\n            else\n                case Dict.get key details.cache of\n                    Just (Loaded state) ->\n                        Just state\n\n                    _ ->\n                        Nothing\n\n\n{-| -}\ninsert : String -> state -> Cache state -> Cache state\ninsert key newState (Cache details) =\n    let\n        state =\n            Loaded newState\n    in\n    case details.current of\n        Nothing ->\n            Cache { details | cache = Dict.insert key state details.cache }\n\n        Just curr ->\n            if curr.key == key then\n                Cache { details | current = Just { curr | state = state } }\n\n            else\n                Cache { details | cache = Dict.insert key state details.cache }\n\n\n{-| -}\ninsertLoaded : String -> Loaded state -> Cache state -> Cache state\ninsertLoaded key state (Cache details) =\n    case details.current of\n        Nothing ->\n            Cache { details | cache = Dict.insert key state details.cache }\n\n        Just currentValue ->\n            if currentValue.key == key then\n                Cache { details | current = Just { currentValue | state = state } }\n\n            else\n                Cache { details | cache = Dict.insert key state details.cache }\n");
  }

}
