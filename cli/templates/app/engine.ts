
import * as path from "path";
import * as fs from "fs";

export const copyTo = (baseDir: string, overwrite: boolean) => { 
  
  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Markdown.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Markdown.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Markdown.elm"), "module App.Markdown exposing (Model, Msg, Page, page)\n\n{-| -}\n\nimport App\nimport Browser\nimport Html exposing (Html)\nimport Http\nimport Markdown.Block\nimport Markdown.Parser\nimport Markdown.Renderer\nimport Result\n\n\ntype alias Model =\n    { source : { sourceUrl : String }\n    , markdown : Result (List String) (List Markdown.Block.Block)\n    }\n\n\ntype Msg\n    = MarkdownReceived (Result Http.Error String)\n\n\ntype alias Page shared =\n    App.Page { sourceUrl : String } shared Model Msg (Browser.Document Msg)\n\n\npage : String -> Page shared\npage markdown =\n    App.page\n        { init =\n            \\params shared ->\n                ( { source = params\n                  , markdown =\n                        Markdown.Parser.parse markdown\n                            |> Result.mapError (List.map Markdown.Parser.deadEndToString)\n                  }\n                , App.get\n                    { url = params.sourceUrl\n                    , expect =\n                        Http.expectString MarkdownReceived\n                    }\n                )\n        , update = update\n        , subscriptions = \\pageUnpack unpack -> App.Subscription Sub.none\n        , view =\n            \\model ->\n                { title = \"test\"\n                , body =\n                    case model.markdown of\n                        Ok parsed ->\n                            case\n                                Markdown.Renderer.render\n                                    Markdown.Renderer.defaultHtmlRenderer\n                                    parsed\n                            of\n                                Ok rendered ->\n                                    rendered\n\n                                Err errorText ->\n                                    [ Html.text errorText ]\n\n                        Err parsingErrors ->\n                            [ Html.text \"Error parsing\" ]\n                }\n        }\n\n\nupdate msg model =\n    case msg of\n        MarkdownReceived (Err err) ->\n            ( model, App.none )\n\n        MarkdownReceived (Ok markdown) ->\n            ( { model\n                | markdown =\n                    Markdown.Parser.parse markdown\n                        |> Result.mapError (List.map Markdown.Parser.deadEndToString)\n              }\n            , App.none\n            )\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Page.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Page.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Page.elm"), "module App.Page exposing\n    ( Page, page\n    , withUrlSync, ParamChange(..)\n    , toInit, toUpdate, toSubscriptions, toView, toUrlSync\n    )\n\n{-|\n\n@docs Page, page\n\n@docs withUrlSync, ParamChange, sendParamsToCurrentPage, loadNewPage\n\n\n# Internal Details\n\n@docs toInit, toUpdate, toSubscriptions, toView, toUrlSync\n\n-}\n\nimport App.Effect\nimport App.Shared\nimport App.Sub\nimport App.View\n\n\n{-| -}\ntype Page params msg model\n    = Page\n        { init : params -> App.Shared.Shared -> Maybe model -> ( model, App.Effect.Effect msg )\n        , update : App.Shared.Shared -> msg -> model -> ( model, App.Effect.Effect msg )\n        , subscriptions : App.Shared.Shared -> model -> App.Sub.Sub msg\n        , view : App.Shared.Shared -> model -> App.View.View msg\n        , urlSync :\n            Maybe\n                { toParams : model -> params\n                , onParamChange : params -> ParamChange msg\n                }\n        }\n\n\n{-| -}\npage :\n    { init : params -> App.Shared.Shared -> Maybe model -> ( model, App.Effect.Effect msg )\n    , update : App.Shared.Shared -> msg -> model -> ( model, App.Effect.Effect msg )\n    , subscriptions : App.Shared.Shared -> model -> App.Sub.Sub msg\n    , view : App.Shared.Shared -> model -> App.View.View msg\n    }\n    -> Page params msg model\npage options =\n    Page\n        { init = options.init\n        , update = options.update\n        , subscriptions = options.subscriptions\n        , view = options.view\n        , urlSync = Nothing\n        }\n\n\n\n{- URL SYNCING -}\n\n\n{-| -}\nwithUrlSync :\n    { toParams : model -> params\n    , onParamChange : params -> ParamChange msg\n    }\n    -> Page params msg model\n    -> Page params msg model\nwithUrlSync urlSync (Page details) =\n    Page { details | urlSync = Just urlSync }\n\n\ntype ParamChange msg\n    = SendParamsToCurrentPage msg\n    | LoadNewPage\n\n\n{-| -}\nsendParamsToCurrentPage : msg -> ParamChange msg\nsendParamsToCurrentPage msg =\n    SendParamsToCurrentPage msg\n\n\n{-| -}\nloadNewPage : ParamChange msg\nloadNewPage =\n    LoadNewPage\n\n\n{-| -}\ntoInit :\n    Page params msg model\n    -> (params -> App.Shared.Shared -> Maybe model -> ( model, App.Effect.Effect msg ))\ntoInit (Page details) =\n    details.init\n\n\n{-| -}\ntoUpdate :\n    Page params msg model\n    -> (App.Shared.Shared -> msg -> model -> ( model, App.Effect.Effect msg ))\ntoUpdate (Page details) =\n    details.update\n\n\n{-| -}\ntoSubscriptions :\n    Page params msg model\n    -> (App.Shared.Shared -> model -> App.Sub.Sub msg)\ntoSubscriptions (Page details) =\n    details.subscriptions\n\n\n{-| -}\ntoView :\n    Page params msg model\n    -> (App.Shared.Shared -> model -> App.View.View msg)\ntoView (Page details) =\n    details.view\n\n\n{-| -}\ntoUrlSync :\n    Page params msg model\n    ->\n        Maybe\n            { toParams : model -> params\n            , onParamChange : params -> ParamChange msg\n            }\ntoUrlSync (Page details) =\n    details.urlSync\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/State.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/State.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/State.elm"), "module App.State exposing\n    ( Cache, init, current, get\n    , insert, setCurrent, toNotFound\n    )\n\n{-|\n\n@docs Cache, init, current, get\n\n#docs setCurrent, insert, toNotFound\n\n-}\n\nimport Dict\n\n\ntype Cache state\n    = Cache\n        { currentKey : Maybe String\n        , current : Maybe state\n        , cache : Dict.Dict String state\n        }\n\n\ninit : Cache state\ninit =\n    Cache\n        { currentKey = Nothing\n        , current = Nothing\n        , cache = Dict.empty\n        }\n\n\ncurrent : Cache state -> Maybe state\ncurrent (Cache details) =\n    details.current\n\n\ntoNotFound : Cache state -> Cache state\ntoNotFound (Cache details) =\n    Cache\n        { details\n            | currentKey = Nothing\n            , current = Nothing\n            , cache =\n                case details.currentKey of\n                    Nothing ->\n                        details.cache\n\n                    Just currentKey ->\n                        case details.current of\n                            Nothing ->\n                                details.cache\n\n                            Just currentState ->\n                                details.cache\n                                    |> Dict.insert currentKey currentState\n        }\n\n\nsetCurrent : String -> Cache state -> Cache state\nsetCurrent key (Cache details) =\n    Cache\n        { details\n            | currentKey = Just key\n            , current = Dict.get key details.cache\n            , cache =\n                case details.currentKey of\n                    Nothing ->\n                        details.cache\n\n                    Just previousCurrentKey ->\n                        if previousCurrentKey == key then\n                            details.cache\n\n                        else\n                            case details.current of\n                                Nothing ->\n                                    details.cache\n\n                                Just previousCurrent ->\n                                    details.cache\n                                        |> Dict.remove key\n                                        |> Dict.insert previousCurrentKey previousCurrent\n        }\n\n\nget : String -> Cache state -> Maybe state\nget key (Cache details) =\n    case details.currentKey of\n        Nothing ->\n            Dict.get key details.cache\n\n        Just currentKey ->\n            if currentKey == key then\n                details.current\n\n            else\n                Dict.get key details.cache\n\n\ninsert : String -> state -> Cache state -> Cache state\ninsert key value (Cache details) =\n    case details.currentKey of\n        Nothing ->\n            Cache { details | cache = Dict.insert key value details.cache }\n\n        Just currentKey ->\n            if currentKey == key then\n                Cache { details | current = Just value }\n\n            else\n                Cache { details | cache = Dict.insert key value details.cache }\n");
  }

}
