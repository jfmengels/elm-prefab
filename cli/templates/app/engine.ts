
import * as path from "path";
import * as fs from "fs";

export const copyTo = (baseDir: string) => { 
  
  fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Markdown.elm")), { recursive: true });
  fs.writeFileSync(path.join(baseDir, "/App/Markdown.elm"), "module App.Markdown exposing (Model, Msg, Page, page)\n\n{-| -}\n\nimport App\nimport Browser\nimport Html exposing (Html)\nimport Http\nimport Markdown.Block\nimport Markdown.Parser\nimport Markdown.Renderer\nimport Result\n\n\ntype alias Model =\n    { source : { sourceUrl : String }\n    , markdown : Result (List String) (List Markdown.Block.Block)\n    }\n\n\ntype Msg\n    = MarkdownReceived (Result Http.Error String)\n\n\ntype alias Page shared =\n    App.Page { sourceUrl : String } shared Model Msg (Browser.Document Msg)\n\n\npage : String -> Page shared\npage markdown =\n    App.page\n        { init =\n            \\params shared ->\n                ( { source = params\n                  , markdown =\n                        Markdown.Parser.parse markdown\n                            |> Result.mapError (List.map Markdown.Parser.deadEndToString)\n                  }\n                , App.get\n                    { url = params.sourceUrl\n                    , expect =\n                        Http.expectString MarkdownReceived\n                    }\n                )\n        , update = update\n        , subscriptions = \\pageUnpack unpack -> App.Subscription Sub.none\n        , view =\n            \\model ->\n                { title = \"test\"\n                , body =\n                    case model.markdown of\n                        Ok parsed ->\n                            case\n                                Markdown.Renderer.render\n                                    Markdown.Renderer.defaultHtmlRenderer\n                                    parsed\n                            of\n                                Ok rendered ->\n                                    rendered\n\n                                Err errorText ->\n                                    [ Html.text errorText ]\n\n                        Err parsingErrors ->\n                            [ Html.text \"Error parsing\" ]\n                }\n        }\n\n\nupdate msg model =\n    case msg of\n        MarkdownReceived (Err err) ->\n            ( model, App.none )\n\n        MarkdownReceived (Ok markdown) ->\n            ( { model\n                | markdown =\n                    Markdown.Parser.parse markdown\n                        |> Result.mapError (List.map Markdown.Parser.deadEndToString)\n              }\n            , App.none\n            )\n");


  fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Page.elm")), { recursive: true });
  fs.writeFileSync(path.join(baseDir, "/App/Page.elm"), "module App.Page exposing\n    ( Page, page\n    , toInit, toUpdate, toSubscriptions, toView\n    )\n\n{-|\n\n@docs Page, page\n\n\n# Internal Details\n\n@docs toInit, toUpdate, toSubscriptions, toView\n\n-}\n\nimport App.Effect\nimport App.Sub\nimport App.View\n\n\n{-| -}\ntype Page params shared msg model\n    = Page\n        { init : params -> shared -> Maybe model -> ( model, App.Effect.Effect msg )\n        , update : shared -> msg -> model -> ( model, App.Effect.Effect msg )\n        , subscriptions : shared -> model -> App.Sub.Sub msg\n        , view : shared -> model -> App.View.View msg\n        }\n\n\n{-| -}\npage :\n    { init : params -> shared -> Maybe model -> ( model, App.Effect.Effect msg )\n    , update : shared -> msg -> model -> ( model, App.Effect.Effect msg )\n    , subscriptions : shared -> model -> App.Sub.Sub msg\n    , view : shared -> model -> App.View.View msg\n    }\n    -> Page params shared msg model\npage =\n    Page\n\n\n{-| -}\ntoInit :\n    Page params shared msg model\n    -> (params -> shared -> Maybe model -> ( model, App.Effect.Effect msg ))\ntoInit (Page details) =\n    details.init\n\n\n{-| -}\ntoUpdate :\n    Page params shared msg model\n    -> (shared -> msg -> model -> ( model, App.Effect.Effect msg ))\ntoUpdate (Page details) =\n    details.update\n\n\n{-| -}\ntoSubscriptions :\n    Page params shared msg model\n    -> (shared -> model -> App.Sub.Sub msg)\ntoSubscriptions (Page details) =\n    details.subscriptions\n\n\n{-| -}\ntoView :\n    Page params shared msg model\n    -> (shared -> model -> App.View.View msg)\ntoView (Page details) =\n    details.view\n");


  fs.mkdirSync(path.dirname(path.join(baseDir, "/App/State.elm")), { recursive: true });
  fs.writeFileSync(path.join(baseDir, "/App/State.elm"), "module App.State exposing\n    ( Cache, init, current, get\n    , insert, setCurrent\n    )\n\n{-|\n\n@docs Cache, init, current, get\n\n#docs setCurrent, insert\n\n-}\n\nimport Dict\n\n\ntype Cache state\n    = Cache\n        { currentKey : Maybe String\n        , current : Maybe state\n        , cache : Dict.Dict String state\n        }\n\n\ninit : Cache state\ninit =\n    Cache\n        { currentKey = Nothing\n        , current = Nothing\n        , cache = Dict.empty\n        }\n\n\ncurrent : Cache state -> Maybe state\ncurrent (Cache details) =\n    details.current\n\n\nsetCurrent : String -> Cache state -> Cache state\nsetCurrent key (Cache details) =\n    Cache\n        { details\n            | currentKey = Just key\n            , current = Dict.get key details.cache\n            , cache =\n                case details.currentKey of\n                    Nothing ->\n                        details.cache\n\n                    Just previousCurrentKey ->\n                        if previousCurrentKey == key then\n                            details.cache\n\n                        else\n                            case details.current of\n                                Nothing ->\n                                    details.cache\n\n                                Just previousCurrent ->\n                                    details.cache\n                                        |> Dict.remove key\n                                        |> Dict.insert previousCurrentKey previousCurrent\n        }\n\n\nget : String -> Cache state -> Maybe state\nget key (Cache details) =\n    case details.currentKey of\n        Nothing ->\n            Dict.get key details.cache\n\n        Just currentKey ->\n            if currentKey == key then\n                details.current\n\n            else\n                Dict.get key details.cache\n\n\ninsert : String -> state -> Cache state -> Cache state\ninsert key value (Cache details) =\n    case details.currentKey of\n        Nothing ->\n            Cache { details | cache = Dict.insert key value details.cache }\n\n        Just currentKey ->\n            if currentKey == key then\n                Cache { details | current = Just value }\n\n            else\n                Cache { details | cache = Dict.insert key value details.cache }\n");

}
