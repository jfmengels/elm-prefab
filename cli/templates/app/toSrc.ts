
import * as path from "path";
import * as fs from "fs";

export const copyTo = (baseDir: string, overwrite: boolean) => { 
  
  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Page/Error.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Page/Error.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Page/Error.elm"), "module App.Page.Error exposing (Error(..))\n\n{-| You may want to protect a page with a certain error when it is first requested.\n\n  - `NotFound` is built in to `elm-prefab`, so you don't need to capture that here.\n\nCommon errors are\n\n    - Unauthenticated — When you require someone to be signed in in order to see a page.\n    - Permission denied — When you require taht someone is both signed in and has certain permissions.\n\n-}\n\n\ntype Error\n    = Unauthenticated\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Page/Id.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Page/Id.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Page/Id.elm"), "module App.Page.Id exposing (Id(..))\n\n{-| -}\n\n\ntype Id\n    = Home HomeParams\n\n\n\n{- Param definitions -}\n\n\ntype alias HomeParams =\n    {}\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Effect.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Effect.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Effect.elm"), "port module App.Effect exposing\n    ( Effect, none, batch, map\n    , now, nowAfter\n    , pushUrl, replaceUrl\n    , forward, back\n    , preload, load, loadAt, reload\n    , sendMsg, sendMsgAfter\n    , generate\n    , focus, blur\n    , file, files, fileToUrl\n    , request, Expect, expectString, expectJson, expectBytes, expectWhatever\n    , toCmd\n    )\n\n{-|\n\n@docs Effect, none, batch, map\n\n\n# Time\n\n@docs now, nowAfter\n\n\n# Navigation\n\n@docs pushUrl, replaceUrl\n\n@docs forward, back\n\n\n# Loading\n\n@docs preload, load, loadAt, reload\n\n\n# Callbacks\n\n@docs sendMsg, sendMsgAfter\n\n\n# Random generation\n\n@docs generate\n\n\n# Browser focus\n\n@docs focus, blur\n\n\n# File selection\n\n@docs file, files, fileToUrl\n\n\n# Http\n\n@docs request, Expect, expectString, expectJson, expectBytes, expectWhatever\n\n\n# Effects\n\n@docs toCmd\n\n-}\n\nimport App.Page.Id\nimport App.Route\nimport App.View.Id\nimport Browser\nimport Browser.Dom\nimport Browser.Navigation\nimport Bytes\nimport Bytes.Decode\nimport File\nimport File.Select\nimport Html\nimport Http\nimport Json.Decode\nimport Json.Encode\nimport Process\nimport Random\nimport Task\nimport Time\n\n\nnone : Effect msg\nnone =\n    None\n\n\nbatch : List (Effect msg) -> Effect msg\nbatch =\n    Batch\n\n\n{-| -}\npushUrl : String -> Effect msg\npushUrl =\n    PushUrl\n\n\n{-| -}\nreplaceUrl : String -> Effect msg\nreplaceUrl =\n    ReplaceUrl\n\n\n{-| -}\nload : String -> Effect msg\nload =\n    Load\n\n\n{-| -}\nloadAt : App.View.Id.Region -> App.Page.Id.Id -> Effect msg\nloadAt region pageId =\n    ViewUpdated (App.View.Id.Push region pageId)\n\n\nclear : App.View.Id.Region -> Effect msg\nclear region =\n    ViewUpdated (App.View.Id.ClearRegion region)\n\n\npreload : App.Page.Id.Id -> Effect msg\npreload =\n    Preload\n\n\nreload : Effect msg\nreload =\n    Reload\n\n\nforward : Int -> Effect msg\nforward =\n    Forward\n\n\nback : Int -> Effect msg\nback =\n    Back\n\n\nsendMsg : msg -> Effect msg\nsendMsg =\n    SendMsg\n\n\nsendMsgAfter : Int -> msg -> Effect msg\nsendMsgAfter delay msg =\n    SendMsgAfter delay msg\n\n\n{-| Get the current time\n-}\nnow : (Time.Posix -> msg) -> Effect msg\nnow =\n    Now Nothing\n\n\n{-| Delay for some number of milliseconds, then get the current time\n-}\nnowAfter : Float -> (Time.Posix -> msg) -> Effect msg\nnowAfter wait =\n    Now (Just wait)\n\n\n{-| Attempt to change the browser focus to the element with a given id.\n-}\nfocus : String -> (Result Browser.Dom.Error () -> msg) -> Effect msg\nfocus =\n    Focus\n\n\n{-| Make a specific element lose focus.\n-}\nblur : String -> (Result Browser.Dom.Error () -> msg) -> Effect msg\nblur =\n    Blur\n\n\n{-| Run a random generator to produce a value.\n-}\ngenerate : (item -> msg) -> Random.Generator item -> Effect msg\ngenerate fn generator =\n    Generate (Random.map fn generator)\n\n\n{-| -}\nfile : List String -> (File.File -> msg) -> Effect msg\nfile =\n    File\n\n\nfiles : List String -> (File.File -> List File.File -> msg) -> Effect msg\nfiles =\n    Files\n\n\nfileToUrl : File.File -> (String -> msg) -> Effect msg\nfileToUrl fileData toMsg =\n    FileToUrl fileData toMsg\n\n\nrequest :\n    { method : String\n    , headers : List Http.Header\n    , url : String\n    , body : Http.Body\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n    -> Effect msg\nrequest options =\n    HttpRequest options\n\n\ntype Effect msg\n    = None\n    | Batch (List (Effect msg))\n      --\n    | SendMsg msg\n    | SendMsgAfter Int msg\n      -- Random generation\n    | Generate (Random.Generator msg)\n      -- Time\n    | Now (Maybe Float) (Time.Posix -> msg)\n      -- Focus/Blur\n    | Focus String (Result Browser.Dom.Error () -> msg)\n    | Blur String (Result Browser.Dom.Error () -> msg)\n      -- Urls\n    | PushUrl String\n    | ReplaceUrl String\n      -- Files\n    | File (List String) (File.File -> msg)\n    | Files (List String) (File.File -> List File.File -> msg)\n    | FileToUrl File.File (String -> msg)\n      -- Loading\n    | ViewUpdated (App.View.Id.Operation App.Page.Id.Id)\n    | Preload App.Page.Id.Id\n    | Load String\n    | Reload\n      -- History navigation\n    | Forward Int\n    | Back Int\n      -- Http\n    | HttpRequest (RequestDetails msg)\n      -- JS interop\n    | SendToWorld\n        { tag : String\n        , details : Maybe Json.Encode.Value\n        }\n\n\ntype alias RequestDetails msg =\n    { method : String\n    , headers : List Http.Header\n    , url : String\n    , body : Http.Body\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n\n\ntype Expect msg\n    = ExpectString (Result Http.Error String -> msg)\n    | ExpectJson (Json.Decode.Decoder msg) (Http.Error -> msg)\n    | ExpectBytes (Bytes.Decode.Decoder msg) (Http.Error -> msg)\n    | ExpectWhatever (Result Http.Error () -> msg)\n\n\nexpectString : (Result Http.Error String -> msg) -> Expect msg\nexpectString =\n    ExpectString\n\n\nexpectJson : Json.Decode.Decoder msg -> (Http.Error -> msg) -> Expect msg\nexpectJson =\n    ExpectJson\n\n\nexpectBytes : Bytes.Decode.Decoder msg -> (Http.Error -> msg) -> Expect msg\nexpectBytes =\n    ExpectBytes\n\n\nexpectWhatever : (Result Http.Error () -> msg) -> Expect msg\nexpectWhatever =\n    ExpectWhatever\n\n\nport outgoing : { tag : String, details : Maybe Json.Encode.Value } -> Cmd msg\n\n\ntoCmd :\n    { options\n        | navKey : Browser.Navigation.Key\n        , preload : App.Page.Id.Id -> msg\n        , regionUpdate : App.View.Id.Operation App.Page.Id.Id -> msg\n    }\n    -> Effect msg\n    -> Cmd msg\ntoCmd options effect =\n    case effect of\n        None ->\n            Cmd.none\n\n        Batch effects ->\n            Cmd.batch (List.map (toCmd options) effects)\n\n        Generate generator ->\n            Random.generate identity generator\n\n        Now Nothing toMsg ->\n            Time.now\n                |> Task.perform toMsg\n\n        Now (Just wait) toMsg ->\n            Process.sleep wait\n                |> Task.andThen\n                    (\\_ -> Time.now)\n                |> Task.perform toMsg\n\n        Focus id toMsg ->\n            Process.sleep 1\n                |> Task.andThen\n                    (\\_ -> Browser.Dom.focus id)\n                |> Task.attempt toMsg\n\n        Blur id toMsg ->\n            Browser.Dom.blur id\n                |> Task.attempt toMsg\n\n        PushUrl url ->\n            Browser.Navigation.pushUrl options.navKey url\n\n        ReplaceUrl url ->\n            Browser.Navigation.replaceUrl options.navKey url\n\n        ViewUpdated op ->\n            Task.succeed ()\n                |> Task.perform\n                    (\\_ ->\n                        options.regionUpdate op\n                    )\n\n        Load url ->\n            Browser.Navigation.load url\n\n        Reload ->\n            Browser.Navigation.reload\n\n        Forward steps ->\n            Browser.Navigation.forward options.navKey steps\n\n        Back steps ->\n            Browser.Navigation.back options.navKey steps\n\n        SendToWorld outgoingMsg ->\n            outgoing outgoingMsg\n\n        SendMsg msg ->\n            Task.succeed ()\n                |> Task.perform (\\_ -> msg)\n\n        SendMsgAfter delay msg ->\n            Process.sleep (toFloat delay)\n                |> Task.map (\\_ -> msg)\n                |> Task.perform identity\n\n        Preload pageId ->\n            Task.succeed ()\n                |> Task.perform (\\_ -> options.preload pageId)\n\n        File extensions toMsg ->\n            File.Select.file extensions toMsg\n\n        Files extensions toMsg ->\n            File.Select.files extensions toMsg\n\n        FileToUrl fileData toMsg ->\n            File.toUrl fileData\n                |> Task.perform toMsg\n\n        HttpRequest req ->\n            Http.request\n                { method = req.method\n                , body = req.body\n                , url = req.url\n                , headers = req.headers\n                , expect = toHttpExpect req.expect\n                , timeout = req.timeout\n                , tracker = req.tracker\n                }\n\n\nmap : (a -> b) -> Effect a -> Effect b\nmap f effect =\n    case effect of\n        None ->\n            None\n\n        Batch effects ->\n            Batch (List.map (map f) effects)\n\n        PushUrl url ->\n            PushUrl url\n\n        ReplaceUrl url ->\n            ReplaceUrl url\n\n        ViewUpdated op ->\n            ViewUpdated op\n\n        Load url ->\n            Load url\n\n        Reload ->\n            Reload\n\n        Forward n ->\n            Forward n\n\n        Back n ->\n            Back n\n\n        SendToWorld { tag, details } ->\n            SendToWorld { tag = tag, details = details }\n\n        SendMsg msg ->\n            SendMsg (f msg)\n\n        SendMsgAfter delay msg ->\n            SendMsgAfter delay (f msg)\n\n        Focus id msg ->\n            Focus id (msg >> f)\n\n        Blur id msg ->\n            Blur id (msg >> f)\n\n        Preload route ->\n            Preload route\n\n        HttpRequest req ->\n            HttpRequest\n                { method = req.method\n                , headers = req.headers\n                , url = req.url\n                , body = req.body\n                , expect = mapExpect f req.expect\n                , timeout = req.timeout\n                , tracker = req.tracker\n                }\n\n        File extensions toMsg ->\n            File extensions (toMsg >> f)\n\n        Files extensions toMsg ->\n            Files extensions (\\top remaining -> toMsg top remaining |> f)\n\n        FileToUrl fileData toMsg ->\n            FileToUrl fileData (toMsg >> f)\n\n        Now maybeWait toMsg ->\n            Now maybeWait (toMsg >> f)\n\n        Generate generator ->\n            Generate (Random.map f generator)\n\n\ntoHttpExpect : Expect msg -> Http.Expect msg\ntoHttpExpect expect =\n    case expect of\n        ExpectString toMsg ->\n            Http.expectString toMsg\n\n        ExpectJson decoder onError ->\n            Http.expectJson\n                (\\result ->\n                    case result of\n                        Err err ->\n                            onError err\n\n                        Ok value ->\n                            value\n                )\n                decoder\n\n        ExpectBytes decoder onError ->\n            Http.expectBytes\n                (\\result ->\n                    case result of\n                        Err err ->\n                            onError err\n\n                        Ok value ->\n                            value\n                )\n                decoder\n\n        ExpectWhatever toMsg ->\n            Http.expectWhatever toMsg\n\n\nmapExpect : (a -> b) -> Expect a -> Expect b\nmapExpect fn expect =\n    case expect of\n        ExpectString toMsg ->\n            ExpectString (toMsg >> fn)\n\n        ExpectJson decoder onError ->\n            ExpectJson (Json.Decode.map fn decoder) (onError >> fn)\n\n        ExpectBytes decoder onError ->\n            ExpectBytes (Bytes.Decode.map fn decoder) (onError >> fn)\n\n        ExpectWhatever toMsg ->\n            ExpectWhatever (toMsg >> fn)\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Page.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Page.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Page.elm"), "module App.Page exposing\n    ( Page, page, authenticated\n    , withKey, withPageCacheLimit\n    , Init, init, initWith, notFound, loadFrom, error\n    )\n\n{-|\n\n@docs Page, page, authenticated\n\n@docs withKey, withPageCacheLimit\n\n@docs Init, init, initWith, notFound, loadFrom, error\n\n-}\n\nimport App.Effect\nimport App.Engine.Page\nimport App.Page.Error\nimport App.Shared\nimport App.Sub\nimport App.View\nimport App.View.Id\n\n\ntype alias Page params msg model =\n    App.Engine.Page.Page App.Shared.Shared params msg model\n\n\n{-| -}\npage :\n    { init : params -> App.Shared.Shared -> Maybe model -> Init msg model\n    , update : App.Shared.Shared -> msg -> model -> ( model, App.Effect.Effect msg )\n    , subscriptions : App.Shared.Shared -> model -> App.Sub.Sub msg\n    , view : App.View.Id.Id -> App.Shared.Shared -> model -> App.View.View msg\n    }\n    -> Page params msg model\npage =\n    App.Engine.Page.page\n\n\n{-| -}\nwithKey : (params -> String) -> Page params msg model -> Page params msg model\nwithKey =\n    App.Engine.Page.withKey\n\n\n{-| This is the maximum number of page instances that will be cached, above what is already visible.\n\nThis defaults to 1.\n\n-}\nwithPageCacheLimit : Int -> Page params msg model -> Page params msg model\nwithPageCacheLimit =\n    App.Engine.Page.withPageCacheLimit\n\n\n{-| -}\nauthenticated :\n    { init : params -> App.Shared.Shared -> Maybe model -> Init msg model\n    , update : App.Shared.Shared -> msg -> model -> ( model, App.Effect.Effect msg )\n    , subscriptions : App.Shared.Shared -> model -> App.Sub.Sub msg\n    , view : App.View.Id.Id -> App.Shared.Shared -> model -> App.View.View msg\n    }\n    -> Page params msg model\nauthenticated options =\n    App.Engine.Page.page options\n        |> App.Engine.Page.withGuard\n            (\\shared ->\n                case shared.authenticated of\n                    App.Shared.Authenticated ->\n                        Ok shared\n\n                    App.Shared.Unauthenticated ->\n                        Err App.Page.Error.Unauthenticated\n            )\n\n\ntype alias Init msg model =\n    App.Engine.Page.Init msg model\n\n\n{-| -}\ninit : model -> Init msg model\ninit =\n    App.Engine.Page.init\n\n\n{-| -}\ninitWith : model -> App.Effect.Effect msg -> Init msg model\ninitWith =\n    App.Engine.Page.initWith\n\n\n{-| -}\nnotFound : Init msg model\nnotFound =\n    App.Engine.Page.notFound\n\n\n{-| -}\nloadFrom : App.Effect.Effect (Init msg model) -> Init msg model\nloadFrom =\n    App.Engine.Page.loadFrom\n\n\n{-| -}\nerror : App.Page.Error.Error -> Init msg model\nerror =\n    App.Engine.Page.error\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Shared.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Shared.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Shared.elm"), "module App.Shared exposing\n    ( Shared\n    , Authenticated(..)\n    )\n\n{-| Data that is shared between the global app and the individual pages.\n\n@docs Shared\n\n@docs Authenticated\n\n-}\n\n\ntype alias Shared =\n    { authenticated : Authenticated }\n\n\ntype Authenticated\n    = Authenticated\n    | Unauthenticated\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/Sub.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/Sub.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/Sub.elm"), "port module App.Sub exposing\n    ( none, batch\n    , map, toSubscription\n    , Sub\n    )\n\n{-|\n\n\n# Subscriptions\n\n@docs Subscription\n\n@docs none, batch\n\n@docs map, toSubscription\n\n-}\n\nimport Json.Encode\nimport Platform.Sub\n\n\ntype Sub msg\n    = Sub (Platform.Sub.Sub msg)\n    | Batch (List (Sub msg))\n\n\n{-| -}\nnone : Sub msg\nnone =\n    Sub Platform.Sub.none\n\n\n{-| -}\nbatch : List (Sub msg) -> Sub msg\nbatch =\n    Batch\n\n\n{-| -}\nmap : (a -> b) -> Sub a -> Sub b\nmap func sub =\n    case sub of\n        Sub subscription ->\n            Sub (Platform.Sub.map func subscription)\n\n        Batch subs ->\n            Batch (List.map (map func) subs)\n\n\n{-| -}\ntoSubscription : { ignore : String -> msg } -> Sub msg -> Platform.Sub.Sub msg\ntoSubscription options sub =\n    case sub of\n        Sub subscription ->\n            subscription\n\n        Batch subs ->\n            Platform.Sub.batch (List.map (toSubscription options) subs)\n\n\nport incoming :\n    ({ tag : String\n     , details : Maybe Json.Encode.Value\n     }\n     -> msg\n    )\n    -> Platform.Sub.Sub msg\n");
  }


  if (overwrite || !fs.existsSync(path.join(baseDir, "/App/View.elm"))) {
    fs.mkdirSync(path.dirname(path.join(baseDir, "/App/View.elm")), { recursive: true });
    fs.writeFileSync(path.join(baseDir, "/App/View.elm"), "module App.View exposing\n    ( View, map\n    , Regions\n    )\n\n{-|\n\n@docs View, map\n\n@docs Regions\n\n-}\n\nimport Html\n\n\ntype alias View msg =\n    { title : String\n    , body : Html.Html msg\n    }\n\n\nmap : (a -> b) -> View a -> View b\nmap fn myView =\n    { title = myView.title\n    , body = Html.map fn myView.body\n    }\n\n\n\n{- Regions -}\n\n\n{-| -}\ntype alias Regions view =\n    { primary : Maybe view\n    , nav : Maybe view\n    , detail : List view\n    }\n");
  }

}
